# Read input data
def readdata(path):
    df=pd.read_excel(path,sheet_name='Adj Close')
    df_re=pd.read_excel(path,sheet_name='Return')
    df['Date']=pd.to_datetime(df['Date'])
    df_re['Date']=pd.to_datetime(df_re['Date'])
    df=df.set_index('Date').sort_index(ascending=True).dropna()
    df_re=df_re.set_index('Date').sort_index(ascending=True).dropna()
    return df,df_re

# Get arithematic mean of assets classes
def arith_avg(df):
    [timeN,assetN]=df.shape
    ArithMean=[]
    for i in range(assetN):
        ArithMean.append(float(df.iloc[:,i].mean()*12))
    ArithMean=np.array(ArithMean)
    return float(np.mean(ArithMean))

# Get geometric mean of assets classes
def geo_avg(df,para):
    [timeN,assetN]=df.shape
    GeoMean=[]
    for i in range(assetN):
        a=np.array(df.iloc[:,i]+1)
        pord=np.prod(a)
        b=float(-1+pord**(1/len(a)))
        GeoMean.append(b)
    GeoMean=np.array(GeoMean)
    if para==0:
        return GeoMean
    elif para==1:
        return 12*float(np.mean(GeoMean))

# Get standard deviation
def sd(w,cov):
    return float(np.sqrt(reduce(np.dot, [w, cov, w.T])))

# Get covariance
def covariance(df1,df2,df3,df4):
    index=df1.index
    df1=df1.mean(1).to_frame()
    df2=df2.mean(1).to_frame()
    df3=df3.mean(1).to_frame()
    df4=df4.mean(1).to_frame()
    df=pd.concat([df1,df2,df3,df4],axis=1)
    cov=df.cov().values
    return cov

# Develop gradiant boosting model to predict returns
def xgboost(returns,factRet):
    [timeN,factorN] = factRet.shape
    [timeN,assetN] = returns.shape
    colName=list(factRet.columns)
    f_bar=factRet.tail(2).mean()
    f_bar=pd.DataFrame(f_bar).T
    f_bar.columns=colName    

    factRet=factRet.head(len(factRet)-1)
    xgb = XGBClassifier(learning_rate=0.1,n_estimators=10,
                                max_depth=7,min_child_weight=2,
                                gamma=0.2,subsample=0.8,
                                colsample_bytree=0.6,objective='reg:linear',
                                scale_pos_weight=1,seed=10) 
    mu=[]
    for i in range(assetN):
        xgb.fit(factRet,returns.iloc[:,i])
        mu.append(float(xgb.predict(f_bar)))
    mu=np.array(mu)
    Q = np.array(returns.cov())
    return mu,Q

# Develop optimization portfolio
def optimization(classRe,classCov,lb,ub,given_r_scale):
    lb=np.array(lb)
    ub=np.array(ub)
    n=len(classRe)
    P=matrix(classCov)
    q=matrix(np.zeros((n, 1)))
    G=np.zeros((2*n,n))
    for i in range(n):
        j=2*i
        G[j,i]=-1
        G[j+1,i]=1
    G=matrix(G)

    h=np.zeros((2*n, 1))
    for i in range(n):
        h[2*i]=-1*lb[i]
        h[2*i+1]=ub[i]
    h=matrix(h)
    aaa=np.ones((1,n))
    A=matrix(np.vstack((aaa,classRe)))

    given_r = []
    risk = []
    weight=[]    
    for temp_r in np.arange(max(min(classRe),0),max(classRe),0.0001):
        try:
            b=matrix(np.array([[1],[temp_r]]))
            options['show_progress'] = False
            options['maxiters']=1000
            outcome = qp(P,q,G,h,A,b)
            x=np.array(outcome['x'])
            
            
            if outcome['status']!='optimal':
                continue
            given_r.append(temp_r)
            risk.append(sd(x.T,classCov))
            
            weight.append(x.round(4))
        except:
            pass     
    index=int(round(given_r_scale*len(given_r),0))
    return np.array(weight[index])

# Develop portfolio with max sharpe ratio
def maxsp(Return,Cov,rf,lb,ub):
    #Construct input matrix
    lb=np.array(lb)
    ub=np.array(ub)
    n=len(Return)
    P=matrix(Cov)
    q=matrix(np.zeros((n, 1)))
    G=np.zeros((2*n,n))
    for i in range(n):
        j=2*i
        G[j,i]=-1
        G[j+1,i]=1
    G=matrix(G)

    h=np.zeros((2*n, 1))
    for i in range(n):
        h[2*i]=-1*lb[i]
        h[2*i+1]=ub[i]
    h=matrix(h)
    aaa=np.ones((1,n))
    A=matrix(np.vstack((aaa,Return)))
    
    given_r = []
    risk = []
    weight=[]    
    
    for temp_r in np.arange(max(min(Return),0),max(Return),0.0001):
        try:
            b=matrix(np.array([[1],[temp_r]]))
            options['show_progress'] = False
            options['maxiters']=1000
            outcome = qp(P,q,G,h,A,b)
            x=np.array(outcome['x'])
            
            
            if outcome['status']!='optimal':
                continue
            given_r.append(temp_r)
            risk.append(sd(x.T,Cov))
            
            weight.append(x.round(4))
        except:
            pass        
    SharpeRatio=(np.array(given_r)-rf)/np.array(risk)
    return weight[SharpeRatio.argmax()]
        
